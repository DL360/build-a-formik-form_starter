"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidatorServiceImpl = void 0;
var guards_1 = require("../models/guards");
/**
 * Class which contains the form validation logic.
 */
var ValidatorServiceImpl = /** @class */ (function () {
    function ValidatorServiceImpl(state, locale, ruleList, messageList, labels) {
        this.state = state;
        this.locale = locale;
        this.ruleList = ruleList;
        this.messageList = messageList;
        this.labels = labels;
        this.errors = [];
        this.messages = this.messageList[this.locale];
    }
    /**
     * Method used to validate a concrete form state with a specific validation.
     * @param fields - fields with custom validation
     * @returns - form validation result object
     */
    ValidatorServiceImpl.prototype.validate = function (fields) {
        this.resetErrors();
        if (!fields)
            return { isValid: true, errors: this.errors };
        for (var _i = 0, _a = Object.keys(this.state); _i < _a.length; _i++) {
            var fieldName = _a[_i];
            var rules = fields[fieldName];
            rules && this.checkRules(fieldName, rules, this.state[fieldName]);
        }
        return { isValid: this.isFormValid(), errors: this.errors };
    };
    /**
     * Use tod check rules associated to a form field.
     * @param fieldName - form field name
     * @param rules - rules associated to field
     * @param value - current form value
     */
    ValidatorServiceImpl.prototype.checkRules = function (fieldName, rules, value) {
        // if value is empty and is not required by the rules, no need to check any other rules
        if (!value && !rules.required) {
            return;
        }
        var ruleKeys = Object.keys(rules);
        for (var _i = 0, ruleKeys_1 = ruleKeys; _i < ruleKeys_1.length; _i++) {
            var ruleKey = ruleKeys_1[_i];
            var validator = this.ruleList[ruleKey];
            var ruleValue = rules[ruleKey];
            var isValid = true;
            if (ruleValue) {
                if ((0, guards_1.isValidatorFn)(validator) && (0, guards_1.isRuleValueForFunction)(ruleValue)) {
                    var validatorFn = validator;
                    isValid = validatorFn(ruleValue, value);
                }
                else if ((0, guards_1.isValidatorRegExp)(validator)) {
                    isValid = validator.test(value);
                }
                !isValid && this.addError(fieldName, ruleKey, ruleValue);
            }
        }
    };
    /**
     * Used to update errors.
     * @param fieldName - form field name
     * @param rule - rules associated to field
     * @param value - current form value
     */
    ValidatorServiceImpl.prototype.addError = function (fieldName, rule, value) {
        var name = this.labels[fieldName];
        value = rule == 'minlength' ? +value - 1 : +value;
        var errMsg = this.messages[rule].replace('{0}', name !== null && name !== void 0 ? name : fieldName).replace('{1}', value.toString());
        var error = this.errors.filter(function (err) { return err.fieldName === fieldName; })[0];
        if (error) {
            var index = this.errors.indexOf(error);
            error.messages.push(errMsg);
            error.failedRules.push(rule);
            this.errors[index] = error;
        }
        else {
            this.errors.push({
                fieldName: fieldName,
                failedRules: [rule],
                messages: [errMsg]
            });
        }
    };
    /**
     * Used to reset errors
     */
    ValidatorServiceImpl.prototype.resetErrors = function () {
        this.errors = [];
    };
    /**
     * Check if form is valid
     * @returns - form validity
     */
    ValidatorServiceImpl.prototype.isFormValid = function () {
        return !this.errors.length;
    };
    return ValidatorServiceImpl;
}());
exports.ValidatorServiceImpl = ValidatorServiceImpl;
